{"version":3,"file":"GeneratedFileWriter.js","sourceRoot":"","sources":["../../../src/cli/core/GeneratedFileWriter.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/restrict-template-expressions */\n\nimport {promises as fs} from 'fs';\nimport vm from 'vm';\nimport path from 'path';\nimport colors from 'colors';\nimport {ClassnamesGenerator} from './ClassnamesGenerator';\nimport {TailwindConfigParser} from './TailwindConfigParser';\nimport {FileContentGenerator} from './FileContentGenerator';\nimport {TTailwindCSSConfig} from '../types/config';\n\ntype TCliOptions = {\n  configFilename: string | void;\n  outputFilename: string | void;\n  customClassesFilename: string | void;\n};\n\n/**\n * Responsible for writing a file with the generated content to the disk.\n */\nexport class GeneratedFileWriter {\n  private readonly _configFilename: string | void;\n  private readonly _outputFilename: string | void;\n  private readonly _customClassesFilename: string | void;\n  /** The data returned from reading the config file */\n  private _configFileData = '';\n\n  /**\n   * Initializes a new instance of `GeneratedFileWriter` class.\n   * @param options The parsed CLI options from user input.\n   */\n  constructor(options: TCliOptions) {\n    this._configFilename = options.configFilename;\n    this._outputFilename = options.outputFilename;\n    this._customClassesFilename = options.customClassesFilename;\n  }\n\n  /**\n   * Writes the generated file to disk.\n   */\n  public write = async (): Promise<void> => {\n    // Check whether the CLI inputs are valid or not\n    try {\n      await this.validateCliOptions();\n    } catch (error) {\n      return;\n    }\n\n    // If the inputs were valid, generate the file content\n    const contentGenerationResult = await this.generateFileContent();\n\n    // Then write the generation result to a file with the provided value from the CLI interface.\n    fs.writeFile(`${this._outputFilename}`, contentGenerationResult, 'utf8')\n      .then(() => {\n        this.printCliMessage(\n          'success',\n          `Types has successfully been generated in ${this._outputFilename} file.`,\n        );\n      })\n      .catch(error => {\n        this.printCliMessage('error', error);\n      });\n  };\n\n  private evaluateTailwindConfigFile = async (): Promise<TTailwindCSSConfig> => {\n    // Read the config file from the provided config path\n    try {\n      this._configFileData = await fs.readFile(`./${this._configFilename}`, {encoding: 'utf-8'});\n    } catch (err) {\n      this.printCliMessage('error', `Error Reading: \"./${this._configFilename}\"`);\n    }\n\n    // Execute the config file content as JavaScript code\n    return <TTailwindCSSConfig>vm.runInNewContext(this._configFileData, {\n      __dirname: path.dirname(path.resolve(`./${this._configFilename}`)),\n      require,\n      module: {},\n      process,\n    });\n  };\n\n  private generateFileContent = async (): Promise<string> => {\n    // Evaluate the config as a JS object\n    const evaluatedConfig = await this.evaluateTailwindConfigFile();\n\n    // Parse the config with the config parser class\n    const configParser = new TailwindConfigParser(evaluatedConfig, {\n      pluginTypography: this._configFileData.includes('@tailwindcss/typography'),\n      pluginCustomForms: this._configFileData.includes('@tailwindcss/custom-forms'),\n    });\n\n    // Generate all classnames from the config\n    const generatedClassnames = new ClassnamesGenerator(configParser).generate();\n\n    // Create the file content from the generated classnames\n    const fileContentTemplate = new FileContentGenerator(\n      generatedClassnames,\n      configParser.getPrefix(),\n    ).generateFileContent();\n\n    // Resolve the custom classes import path relative to the output file\n    let customClassesImportPath: string | null = null;\n    if (!!this._outputFilename && !!this._customClassesFilename) {\n      customClassesImportPath = path\n        .join(\n          path.relative(\n            path.join(process.cwd(), path.dirname(this._outputFilename)),\n            path.join(process.cwd(), path.dirname(this._customClassesFilename)),\n          ),\n          path.basename(this._customClassesFilename),\n        )\n        // Convert any Windows path separators to posix\n        .replace(/\\\\/g, '/')\n        .replace(/(\\.d)?\\.ts$/, '');\n      customClassesImportPath =\n        customClassesImportPath[0] === '.'\n          ? customClassesImportPath\n          : `./${customClassesImportPath}`;\n    }\n\n    // Return final file content\n    return (\n      fileContentTemplate\n        // Append the custom classes types from external file if provided.\n        .replace(\n          /T_CUSTOM_CLASSES_IMPORT_STATEMENT/g,\n          !!customClassesImportPath\n            ? `import type TCustomClassesFromExternalFile from '${customClassesImportPath}';`\n            : '',\n        )\n        .replace(\n          / ?IMPORTED_T_CUSTOM_CLASSES_KEY/g,\n          !!customClassesImportPath ? ' | TCustomClassesFromExternalFile' : '',\n        )\n        .replace(\n          / ?IMPORTED_T_CUSTOM_CLASSES_ARG/g,\n          !!customClassesImportPath ? '| TCustomClassesFromExternalFile\\n' : '',\n        )\n    );\n  };\n\n  private validateCliOptions = (): Promise<void> => {\n    // Check for missing cli options\n    if (!this._configFilename) {\n      this.printCliMessage('error', 'tailwindcss config file name or path is not provided');\n      throw new Error();\n    }\n    if (!this._outputFilename) {\n      this.printCliMessage('error', 'Please provide a valid filename to add generated types to it');\n      throw new Error();\n    }\n\n    // Check for invalid custom classes file content\n    if (!!this._customClassesFilename) {\n      return fs\n        .readFile(`./${this._customClassesFilename}`)\n        .then(data => {\n          if (!data.toString().includes('export default')) {\n            this.printCliMessage(\n              'error',\n              'The type having the custom classes must be a default export',\n            );\n          }\n        })\n        .catch(error => {\n          this.printCliMessage('error', `Unable to read the file with custom types. ${error}`);\n          throw new Error();\n        });\n    }\n\n    return Promise.resolve();\n  };\n\n  private printCliMessage = (type: 'error' | 'success', message: string): void => {\n    const formattedMessage = '\\n\\n' + message + '\\n' + '\\n\\n';\n\n    switch (type) {\n      case 'success':\n        console.log(colors.black.bgGreen(formattedMessage));\n        break;\n      case 'error':\n        console.error(colors.white.bgRed(formattedMessage));\n        break;\n      default:\n        console.log(formattedMessage);\n        break;\n    }\n  };\n}\n"]}