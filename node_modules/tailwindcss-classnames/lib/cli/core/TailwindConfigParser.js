"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TailwindConfigParser = void 0;
var tslib_1 = require("tslib");
var lodash_1 = tslib_1.__importDefault(require("lodash"));
var defaultTailwindConfig_1 = require("../lib/defaultTailwindConfig");
/* eslint-disable @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-return */
/**
 * Parses the tailwind config object
 */
var TailwindConfigParser = /** @class */ (function () {
    function TailwindConfigParser(tailwindConfig, plugins) {
        var _this = this;
        /**
         *  Gets the config mode value
         */
        this.getMode = function () { return _this._mode; };
        /**
         *  Gets the config prefix value
         */
        this.getPrefix = function () { return _this._prefix; };
        /**
         *  Gets the config dark mode value
         */
        this.getDarkMode = function () { return _this._darkMode; };
        /**
         * Gets the config separator value
         */
        this.getSeparator = function () { return _this._separator; };
        /**
         * Gets the config plugins value
         */
        this.getPlugins = function () {
            var _a = _this._pluginsConfig, pluginTypography = _a.pluginTypography, pluginCustomForms = _a.pluginCustomForms;
            return pluginTypography || pluginCustomForms ? _this._pluginsConfig : null;
        };
        /**
         *  Gets the config theme object
         */
        this.getTheme = function () {
            var _a;
            // Check whether config was evaluated before; if yes, return cached result instead of re-calc
            if (_this._evaluatedTheme) {
                return _this._evaluatedTheme;
            }
            /** Evaluate function closures inside theme config and get the evaluated theme object */
            var evaluateTheme = function (valueSourceTheme) {
                // Pick the theme config items except theme.extend
                var coreTheme = lodash_1.default.omit(_this._themeConfig, 'extend');
                // Iterate over theme object items and run the evaluator on it
                var valueEvaluator = new ThemeClosuresEvaluator(coreTheme);
                for (var _i = 0, _a = Object.entries(_this._themeConfig); _i < _a.length; _i++) {
                    var _b = _a[_i], key = _b[0], value = _b[1];
                    var evaluatorResult = valueEvaluator.evaluate(value, valueSourceTheme);
                    // Need to make sure that extensions for specific properties are considered
                    // For example when 'width' is extended, which is originally based on spacing
                    if (valueSourceTheme && lodash_1.default.isObject(evaluatorResult)) {
                        var sourceValue = valueSourceTheme[key];
                        evaluatorResult = tslib_1.__assign(tslib_1.__assign({}, (lodash_1.default.isObject(sourceValue) ? sourceValue : {})), evaluatorResult);
                    }
                    coreTheme[key] = evaluatorResult;
                }
                // Return the result of evaluation
                return coreTheme;
            };
            /** Evaluate function closures inside theme.extend config and get the evaluated theme.extend object */
            var evaluateThemeExtend = function () {
                // Get the theme.extend property value
                var themeExtend = _this._themeConfig.extend;
                // Only when theme.extend exists...
                if (themeExtend) {
                    // Iterate over every item and evaluate closures in it
                    var valueEvaluator = new ThemeClosuresEvaluator(themeExtend);
                    for (var _i = 0, _a = Object.entries(themeExtend); _i < _a.length; _i++) {
                        var _b = _a[_i], key = _b[0], value = _b[1];
                        themeExtend[key] = valueEvaluator.evaluate(value);
                    }
                }
                // Return the result of the evaluation
                return themeExtend;
            };
            // Merge theme with extensions
            var themeWithMergedExtend = lodash_1.default.merge(evaluateTheme(), evaluateThemeExtend());
            // Evaluate the theme again, however taking the values from the merge result
            _this._evaluatedTheme = evaluateTheme(themeWithMergedExtend);
            (_a = _this._evaluatedTheme) === null || _a === void 0 ? true : delete _a.extend;
            // Return the evaluated theme
            return _this._evaluatedTheme;
        };
        /**
         * Get config variants object
         */
        this.getVariants = function () {
            var _a;
            // Get the `variants.extend` object
            var variantsConfigExtend = (_a = _this._variantsConfig) === null || _a === void 0 ? void 0 : _a.extend;
            // If the variants.extend exists...
            if (!!variantsConfigExtend) {
                // Return the result of merging the variants with extend
                return lodash_1.default.mergeWith(_this._variantsConfig, variantsConfigExtend, function (variantsValues, variantsExtendValues) {
                    if (lodash_1.default.isArray(variantsValues)) {
                        return variantsValues.concat(variantsExtendValues);
                    }
                });
                // Otherwise...
            }
            else {
                // Return the variants
                return _this._variantsConfig;
            }
        };
        /**
         * Get the value (and key) of a supplied theme property.
         * @param themeProperty The theme property name
         */
        this.getThemeProperty = function (themeProperty) {
            return [
                Object.keys(_this.getTheme()[themeProperty]),
                Object.values(_this.getTheme()[themeProperty]),
            ];
        };
        this._mode = tailwindConfig === null || tailwindConfig === void 0 ? void 0 : tailwindConfig.mode;
        this._prefix = lodash_1.default.isEmpty(tailwindConfig === null || tailwindConfig === void 0 ? void 0 : tailwindConfig.prefix) ? '' : tailwindConfig.prefix;
        this._darkMode = lodash_1.default.isEmpty(tailwindConfig === null || tailwindConfig === void 0 ? void 0 : tailwindConfig.darkMode)
            ? false
            : tailwindConfig.darkMode;
        this._separator = lodash_1.default.isEmpty(tailwindConfig.separator)
            ? ':'
            : tailwindConfig.separator;
        this._variantsConfig = lodash_1.default.isEmpty(tailwindConfig.variants)
            ? defaultTailwindConfig_1.defaultTailwindConfig.variants // Order does matter, defaultVariants will be overridden by themeVariants.
            : tslib_1.__assign(tslib_1.__assign({}, defaultTailwindConfig_1.defaultTailwindConfig.variants), tailwindConfig.variants);
        this._themeConfig = tslib_1.__assign(tslib_1.__assign({}, defaultTailwindConfig_1.defaultTailwindConfig.theme), tailwindConfig.theme);
        this._evaluatedTheme = null;
        this._pluginsConfig = plugins;
    }
    return TailwindConfigParser;
}());
exports.TailwindConfigParser = TailwindConfigParser;
/**
 * The class responsible for evaluating the closures inside the config.
 */
var ThemeClosuresEvaluator = /** @class */ (function () {
    function ThemeClosuresEvaluator(themeConfig) {
        this.themeConfig = themeConfig;
        /**
         * Creates evaluator for `theme()` functions/closures in config file
         */
        this.makeThemePathResolver = function (theme) { return function (path) {
            return lodash_1.default.get(theme, lodash_1.default.trim(path, "'\""));
        }; };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ThemeClosuresEvaluator.prototype.evaluate = function (value, valueSourceTheme) {
        // If a value is a function...
        if (lodash_1.default.isFunction(value)) {
            // evaluate the value by running the evaluator methods in this class.
            return value(this.makeThemePathResolver(valueSourceTheme || this.themeConfig), {
                negative: ThemeClosuresEvaluator.negative.bind(this),
                breakpoints: ThemeClosuresEvaluator.breakpoints.bind(this),
            });
        }
        // Otherwise, return the value.
        else {
            return value;
        }
    };
    /**
     * Evaluate `negative()` functions/closures
     */
    ThemeClosuresEvaluator.negative = function (item) {
        var itemCopy = tslib_1.__assign({}, item);
        for (var _i = 0, _a = Object.entries(itemCopy); _i < _a.length; _i++) {
            var key = _a[_i][0];
            itemCopy['-' + key] = itemCopy[key];
            delete itemCopy[key];
        }
        return itemCopy;
    };
    /**
     * Evaluate `breakpoints()` functions/closures
     */
    ThemeClosuresEvaluator.breakpoints = function (item) {
        var itemCopy = tslib_1.__assign({}, item);
        for (var _i = 0, _a = Object.entries(itemCopy); _i < _a.length; _i++) {
            var key = _a[_i][0];
            itemCopy['screen-' + key] = itemCopy[key];
            delete itemCopy[key];
        }
        return itemCopy;
    };
    return ThemeClosuresEvaluator;
}());
//# sourceMappingURL=TailwindConfigParser.js.map