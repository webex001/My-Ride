/* eslint-disable @typescript-eslint/restrict-template-expressions */
import { __awaiter, __generator } from "tslib";
import { promises as fs } from 'fs';
import vm from 'vm';
import path from 'path';
import colors from 'colors';
import { ClassnamesGenerator } from './ClassnamesGenerator';
import { TailwindConfigParser } from './TailwindConfigParser';
import { FileContentGenerator } from './FileContentGenerator';
/**
 * Responsible for writing a file with the generated content to the disk.
 */
var GeneratedFileWriter = /** @class */ (function () {
    /**
     * Initializes a new instance of `GeneratedFileWriter` class.
     * @param options The parsed CLI options from user input.
     */
    function GeneratedFileWriter(options) {
        var _this = this;
        /** The data returned from reading the config file */
        this._configFileData = '';
        /**
         * Writes the generated file to disk.
         */
        this.write = function () { return __awaiter(_this, void 0, void 0, function () {
            var error_1, contentGenerationResult;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.validateCliOptions()];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        error_1 = _a.sent();
                        return [2 /*return*/];
                    case 3: return [4 /*yield*/, this.generateFileContent()];
                    case 4:
                        contentGenerationResult = _a.sent();
                        // Then write the generation result to a file with the provided value from the CLI interface.
                        fs.writeFile("" + this._outputFilename, contentGenerationResult, 'utf8')
                            .then(function () {
                            _this.printCliMessage('success', "Types has successfully been generated in " + _this._outputFilename + " file.");
                        })
                            .catch(function (error) {
                            _this.printCliMessage('error', error);
                        });
                        return [2 /*return*/];
                }
            });
        }); };
        this.evaluateTailwindConfigFile = function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, err_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        _a = this;
                        return [4 /*yield*/, fs.readFile("./" + this._configFilename, { encoding: 'utf-8' })];
                    case 1:
                        _a._configFileData = _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        err_1 = _b.sent();
                        this.printCliMessage('error', "Error Reading: \"./" + this._configFilename + "\"");
                        return [3 /*break*/, 3];
                    case 3: 
                    // Execute the config file content as JavaScript code
                    return [2 /*return*/, vm.runInNewContext(this._configFileData, {
                            __dirname: path.dirname(path.resolve("./" + this._configFilename)),
                            require: require,
                            module: {},
                            process: process,
                        })];
                }
            });
        }); };
        this.generateFileContent = function () { return __awaiter(_this, void 0, void 0, function () {
            var evaluatedConfig, configParser, generatedClassnames, fileContentTemplate, customClassesImportPath;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.evaluateTailwindConfigFile()];
                    case 1:
                        evaluatedConfig = _a.sent();
                        configParser = new TailwindConfigParser(evaluatedConfig, {
                            pluginTypography: this._configFileData.includes('@tailwindcss/typography'),
                            pluginCustomForms: this._configFileData.includes('@tailwindcss/custom-forms'),
                        });
                        generatedClassnames = new ClassnamesGenerator(configParser).generate();
                        fileContentTemplate = new FileContentGenerator(generatedClassnames, configParser.getPrefix()).generateFileContent();
                        customClassesImportPath = null;
                        if (!!this._outputFilename && !!this._customClassesFilename) {
                            customClassesImportPath = path
                                .join(path.relative(path.join(process.cwd(), path.dirname(this._outputFilename)), path.join(process.cwd(), path.dirname(this._customClassesFilename))), path.basename(this._customClassesFilename))
                                // Convert any Windows path separators to posix
                                .replace(/\\/g, '/')
                                .replace(/(\.d)?\.ts$/, '');
                            customClassesImportPath =
                                customClassesImportPath[0] === '.'
                                    ? customClassesImportPath
                                    : "./" + customClassesImportPath;
                        }
                        // Return final file content
                        return [2 /*return*/, (fileContentTemplate
                                // Append the custom classes types from external file if provided.
                                .replace(/T_CUSTOM_CLASSES_IMPORT_STATEMENT/g, !!customClassesImportPath
                                ? "import type TCustomClassesFromExternalFile from '" + customClassesImportPath + "';"
                                : '')
                                .replace(/ ?IMPORTED_T_CUSTOM_CLASSES_KEY/g, !!customClassesImportPath ? ' | TCustomClassesFromExternalFile' : '')
                                .replace(/ ?IMPORTED_T_CUSTOM_CLASSES_ARG/g, !!customClassesImportPath ? '| TCustomClassesFromExternalFile\n' : ''))];
                }
            });
        }); };
        this.validateCliOptions = function () {
            // Check for missing cli options
            if (!_this._configFilename) {
                _this.printCliMessage('error', 'tailwindcss config file name or path is not provided');
                throw new Error();
            }
            if (!_this._outputFilename) {
                _this.printCliMessage('error', 'Please provide a valid filename to add generated types to it');
                throw new Error();
            }
            // Check for invalid custom classes file content
            if (!!_this._customClassesFilename) {
                return fs
                    .readFile("./" + _this._customClassesFilename)
                    .then(function (data) {
                    if (!data.toString().includes('export default')) {
                        _this.printCliMessage('error', 'The type having the custom classes must be a default export');
                    }
                })
                    .catch(function (error) {
                    _this.printCliMessage('error', "Unable to read the file with custom types. " + error);
                    throw new Error();
                });
            }
            return Promise.resolve();
        };
        this.printCliMessage = function (type, message) {
            var formattedMessage = '\n\n' + message + '\n' + '\n\n';
            switch (type) {
                case 'success':
                    console.log(colors.black.bgGreen(formattedMessage));
                    break;
                case 'error':
                    console.error(colors.white.bgRed(formattedMessage));
                    break;
                default:
                    console.log(formattedMessage);
                    break;
            }
        };
        this._configFilename = options.configFilename;
        this._outputFilename = options.outputFilename;
        this._customClassesFilename = options.customClassesFilename;
    }
    return GeneratedFileWriter;
}());
export { GeneratedFileWriter };
//# sourceMappingURL=GeneratedFileWriter.js.map