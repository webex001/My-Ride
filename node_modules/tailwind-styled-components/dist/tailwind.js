"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const domElements_1 = __importDefault(require("./domElements"));
const tailwindcss_classnames_1 = require("tailwindcss-classnames");
const cleanTemplate = (template, inheritedClasses = "") => {
    const newClasses = template
        .toString()
        .trim()
        .replace(/\s{2,}/g, " ")
        .split(" ")
        .filter((c) => c !== ",");
    const inheritedClassesArray = inheritedClasses ? inheritedClasses.split(" ") : [];
    return tailwindcss_classnames_1.classnames(...inheritedClassesArray
        .concat(newClasses)
        .filter((c) => c !== " ")
        .filter((v, i, arr) => arr.indexOf(v) === i)).split(" ");
};
function parseTailwindClassNames(template, ...templateElements) {
    return template
        .reduce((sum, n) => {
        return `${sum} ${n}`;
    }, templateElements.join(' '))
        .trim()
        .replace(/\s{2,}/g, " ");
}
function functionTemplate(Element) {
    return (template, ...templateElements) => react_1.default.forwardRef((props, ref) => (react_1.default.createElement(Element, Object.assign({}, Object.fromEntries(Object.entries(props).filter(([key]) => key.charAt(0) !== "$")), { ref: ref, className: parseTailwindClassNames(cleanTemplate(template, props.className), ...templateElements.map((t) => t(props))) }))));
}
const intrinsicElements = domElements_1.default.reduce((acc, DomElement) => ({
    ...acc,
    [DomElement]: functionTemplate(DomElement)
}), {});
const tw = Object.assign(functionTemplate, intrinsicElements);
exports.default = tw;
//# sourceMappingURL=tailwind.js.map